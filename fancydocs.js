registerProject({"title":"backbone-xhr-events","summary":"Do more than what the default [Backbone](#link/http%3A%2F%2Fhttp%3A%2F%2Fbackbonejs.org%2F) Model/Collection ```request``` event does for you.  The primary benefits are\n\n\n\n* Provide robust lifecycle events (```before-send```, ```after-send```, ```success```, ```error```, ```complete```)\n* Emit type specific XHR events to allow for focused binding\n* Give ability to see if a model currently has any pending XHR activity\n* Provide a global event bus to bind to all Model/Collection XHR activity\n* Allow requests to be intercepted to, for example, return cached content\n* Add ability to intercept and override response data before it is returned to the Model/Collection\n* Provide event forwarding capabilities so other objects can simulate XHR activity to match another Model/Collection\n* Make all event names and additional attributes overrideable to meet the needs of your particular project\n* Give external entities a way to observe ajax activity on your Collections and Models","installation":"Browser:\n```\n<script src=\".../underscore[-min].js\"></script>\n<script src=\".../backbone[-min].js\"></script>\n<script src=\".../backbone-xhr-events[-min].js\"></script>\n```\nCommonJS\n```\nrequire('backbone-xhr-events')(require('backbone'), require('underscore'));\n```\nAMD\n```\nrequire(\n  ['backbone', 'underscore', 'backbone-xhr-events'], function(Backbone, _, backboneXhrEvents) {\n  backboneXhrEvents(Backbone, _); \n});\n```\n\n","sections":[{"body":"Bind to a model to listen to all XHR activity\n```\n// method is \"read\", \"save\", or \"delete\" or custom (Backbone.sync method)\n// context is a Backbone.Events to bind to XHR lifecycle events\nmodel.on('xhr', function(method, context) {\n  // 'xhr' event is sent before core Backbone.sync is executed\n\n  // xhr = the XMLHttpRequest; settings = $.ajax settings\n  context.on('before-send', function(xhr, settings, context) {\n    // after core Backbone.sync has executed $.ajax and an XMLHttpRequest has been created\n    // but before the XHR has been executed = $.ajax settings\n  });\n\n  context.on('after-send', function(p1, p2, p3, responseType {\n    // after the XHR has returned but before Backbone.sync has handled the response\n\n    if (responseType === 'success') {\n      // additional params are (data, status, xhr, context);\n    }\n    if (responseType === 'error') {\n      // additional params are (xhr, type, error)\n    }\n\n  });\n\n  context.on('success', function(context) {\n    // this will be called after the XHR succeeds\n  });\n\n  context.on('error', function(xhr, type, error, context) {\n    // this will be called if the XHR fails\n  });\n\n  context.on('complete', function(type, {type specific args}) {\n    // type will either be \"success\" or \"error\" and the type specific args are the same as what is provided to the respective events\n    // this will be called when the XHR succeeds or fails\n  });\n});\n```\n\nBind to a model to listen to only fetches\n```\nmodel.on('xhr:read', function(context) {\n  ...\n});\n```\n\nOverride the XHR payload or cache it\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  context.on('after-send', function(data, status, xhr, responseType, context) {\n    if (responseType === 'success') {\n      // wrap the response as a \"response\" attribute\n      context.data = { response: data };\n      // cache the response\n      if (method === 'read') {\n        _cacheFetchResponse(JSON.stringify(data), context.options.url);\n      }\n    }\n  });\n});\n```\n\nIntercept a request and return a cached payload\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  if (context.method === 'read') {\n    var cachedResult = _getFetchCache(context.options.url);\n    if (cachedResult) {\n      context.preventDefault = true;\n      options.success(JSON.parse(cachedResult), 'success');\n    }\n  }\n});\n```\n\nMake a successful XHR look like a failure\n```\nmodel.on('xhr', function(method, context) {\n  context.on('after-send', function(data, status, xhr, responseType) {\n    if (!context.preventDefault) {\n      // we don't want to call success/error callback more than once\n      context.preventDefault = true;\n\n      // provide the parameters that you would have wanted coming back directly from the $.ajax callback\n      context.options.error(...);\n    }\n  });\n});\n```\n\nSet a default timeout on all XHR activity\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  context.options.timeout = 3000;\n});\n```\n\nDetermine fetch status of a model\n```\nmodel.fetch();\n!!model.xhrActivity === true;\n\n// model fetch complete now\n!!model.xhrActivity === false;\n\n// if the model fetch succeeded\nmodel.hasBeenFetched === true;\nmodel.hadFetchError === false;\n\n// if the model fetch has failed...\nmodel.hadFetchError === true;\nmodel.hasBeenFetched === false;\n```\n\nForward xhr events to another model\n(source model will continue to emit xhr events as well)\n```\n// forward all events\nBackbone.forwardXhrEvents(sourceModel, receiverModel);\n// stop forwarding all events\nBackbone.stopXhrForwarding(sourceModel, receiverModel);\n\n// forward events for a specific Backbone.sync method\nBackbone.forwardXhrEvents(sourceModel, receiverModel, 'read');\n// stop forwarding all events\nBackbone.stopXhrForwarding(sourceModel, receiverModel, 'read');\n\n// forward events *only while the callback function is executed*\nBackbone.forwardXhrEvents(sourceModel, receiverModel, function() {\n  // any XHR activity that sourceModel executes will be emitted by\n  // receiverModel as well\n});\n```\n\nPrevent duplicate concurrent submission of any XHR request\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  context.on('before-send', function(xhr, settings) {\n    // we need to use before-send because Backbone.sync creates settings.data\n\n    // see if any current XHR activity matches this request\n    var match = _.find(model.xhrActivity, function(_context) {\n      return context.options.url === _context.options.url\n          && method === _context.method\n          && _.isEqual(settings.data, _context.settings.data);\n    });\n    if (match) {\n      // when the pending request comes back, simulate the same activity on this request\n      match.on('after-send', context.options.success);\n      match.on('error', context.options.error);\n      context.preventDefault = true;\n    }\n  });\n});\n```\n\nPrevent the error callback if the request is aborted\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  context.on('after-send', function(xhr, errorType, error, responseType) {\n    if (errorType === 'abort') {\n      context.preventDefault = true;\n    }\n  });\n});\n```","title":"General Usage Examples","sections":[]},{"body":"Every event has a \"context\" parameter.  This object is an event emitter as well as an object used for request scoped attributes.","title":"Request Context","sections":[{"body":"All XHR events provide a ```context``` as a parameter.  This is an object extending Backbone.Events and is used to bind to the XHR lifecycle events including\n\n* ***before-send***: after Backbone.sync has been executed and an XHR object has been created (but before execution), set context.preventDefault to stop processing.  Unlike other events, the signature here is (xhr, settings, context) where settings is the actual jquery settings object sent by Backbone.sync.\n* ***after-send***: ({jquery error or success callback params (data, status, xhr) or (xhr, type, error)}, responseType, context) before the model has handled the response\n* ***success***: (context) when the XHR has completed sucessfully\n* ***error***: (xhr, type, error, context) when the XHR has failed\n* ***complete***: ('success|error', {success or error specific params}) when the XHR has either failed or succeeded","title":"Context Lifecycle Events","sections":[]},{"body":"The following read-only context attributes are applicable\n\n* ***options***: the Backbone.ajax options\n* ***settings***: available on \"before-send\" event; the jquery settings object provided by Backbone.sync\n* ***xhr***: the actual XMLHttpRequest\n* ***method***: the Backbone.sync method\n* ***model***: the associated model\n\nThese attributes can be set on the context to alter lifecycle behavior\n\n* ***preventDefault***: set this value as true at any stage to prevent further processing.  In this case, you must context.options callbacks manually or they will not be called at all.\n* ***data***: set this value within an \"after-send\" event handler to override the standard response data","title":"Context Attributes","sections":[]},{"body":"* ***abort***: if after \"before-send\" lifecycle this will call ```abort``` on the source ```XMLHttpRequest```","title":"Context methods","sections":[]}]},{"body":"Almost all event names and model/global attributes can be overridden to suit your needs.\n\n* ***Backbone.xhrCompleteEventName***: the event triggered on a model/collection when all XHR activity has completed (default: ```xhr:complete```)\n* ***Backbone.xhrModelLoadingAttribute***: the model attribute which can be used to return an array of all current XHR request events and determind if the model/collection has current XHR activity (default: ```xhrActivity```)\n* ***Backbone.xhrEventName***: the event triggered on models/collection and the global bus to signal an XHR request (default: ```xhr```)\n* ***Backbone.xhrGlobalAttribute***: global event handler attribute name (on Backbone) used to subscribe to all model xhr events (default: ```xhrEvents```)","title":"Overrides","sections":[]}],"api":{"Events":{"methods":{},"packages":{"\"xhr\"":{"overview":"Callback function arguments are (method, context)\n* ***method***: the Backbone sync method (by default, \"read\", \"update\", or \"delete\")\n* ***context***: the request context (see \"Request Context\" section)\n\nEmitted when any XHR activity occurs\n\n```\nmodel.on('xhr', function(method, context) {\n  // method is \"read\", \"save\", or \"delete\" or custom (Backbone.sync method)\n  // context is a Backbone.Events to bind to XHR lifecycle events\n\n  context.on('complete', function(type, {type specific args}) {\n    // type will either be \"success\" or \"error\" and the type specific args are the same as what is provided to the respective events\n    // this will be called when the XHR succeeds or fails\n  });\n  context.on('success', function(model) {\n    // this will be called after the XHR succeeds\n  });\n  context.on('error', function(model, xhr, type, error) {\n    // this will be called if the XHR fails\n  });\n});\n```\n\nOr, all xhr events are emitted globally on Backbone.xhrEvents.  The signature is similar except that the model is provided.\n```\nBackbone.xhrEvents.on('xhr', function(method, model, context) {\n  ...\n});\n```","methods":{}},"\"xhr:{method}\"":{"overview":"Callback function arguments are (context)\n* ***method***: the Backbone sync method (by default, \"read\", \"update\", or \"delete\")\n* ***context***: the request context (see \"Request Context\" section)\n\nEmitted when only XHR activity matching the method in the event name occurs\n\n```\nmodel.on('xhr:read', function(method, context) {\n  ...\n});\n```\n\nOr, all xhr events are emitted globally on Backbone.xhrEvents.  The signature is similar except that the model is provided.\n```\nBackbone.xhrEvents.on('xhr:read', function(method, model, context) {\n  ...\n});\n```","methods":{}},"\"xhr:complete\"":{"overview":"Callback function arguments are (context)\n* ***context***: the context representing the *last* XHR activity\n\nEmitted when any XHR activity has completed and there is no more concurrent XHR activity","methods":{}}}},"API":{"methods":{},"packages":{"Backbone.Model / Backbone.Collection":{"overview":"","methods":{"whenFetched":{"profiles":["successCallback, errorCallback"],"params":{"successCallback":"function to be called when the model/collection has been fetched","errorCallback":"function to be called when if model/collection fetch failed"},"summary":"Initiate a fetch if not already fetching or fetched.  Once the model/collection has been fetch, execute the appropriate callback.","dependsOn":[],"overview":"```\nmyModel.whenFetched(function(model) {\n    // executed when model is fetched (model and myModel are the same)\n  },\n  function(model) {\n    // executed if the model fetch fails\n  }\n);\n```"}}},"Backbone":{"overview":"","methods":{"forwardXhrEvents":{"profiles":["sourceModel, destModel[, method]) or (sourceModel, destModel, autoStopFunc"],"params":{"sourceModel":"the originator model of the XHR events","destModel":"the receiver or proxy of the source model XHR events","method":"the optional Backbone.sync method to filter the forwarded events","autoStopFunc":"callback function that, if provided, will stop the forwarding after the function completes execution"},"summary":"Forward XHR events that originate in ```sourceModel``` to ```destModel```.  These events will also be emitted in ```sourceModel``` as well.","dependsOn":[],"overview":"This can be useful if you have a composite model containing sub-models and want to aggregate xhr activity to the composite model.\n\n```\nvar CompositeModel = Backbone.Model.extend({\n  initialize: function() {\n    // when model1 or model2 have xhr activity, \"this\" will expose the same xhr events\n    Backbone.Model.prototype.initialize.apply(this, arguments);\n    this.model1 = new Backbone.Model();\n    Backbone.forwardXhrEvents(this.model1, this);\n    this.model2 = new Backbone.Model();\n    Backbone.forwardXhrEvents(this.model2, this);\n  }\n});\n```"},"stopXhrForwarding":{"profiles":["sourceModel, destModel[, method]"],"params":{"sourceModel":"the originator model of the XHR events","destModel":"the receiver or proxy of the source model XHR events","method":"the optional Backbone.sync method to filter the forwarded events"},"summary":"Stop forwarding XHR events.  This must match a previous ```forwardXhrEvents``` call.","dependsOn":[],"overview":""}}}}}}});
